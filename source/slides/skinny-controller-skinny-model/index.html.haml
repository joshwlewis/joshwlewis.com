---
title: Skinny Controller, Skinny Model
published: true
description: 'Skinny Controller, Fat Model' is an old Rails mantra, but a
  poor goal, an anti-pattern, and an easy trap to fall into. There is a better
  way...
---

= step :title do
  %h1.display-4.mb-2
    Skinny Controller,
    %br
    Skinny Model
  %br
  %h4
    %a{ href: "//twitter.com/joshwlewis" } @joshwlewis
    = " - "
    %a{ href: '//twitter.com/heroku.com' } @heroku
  %br
  %h4
    %a{ href: '//joshwlewis.com/slides/skinny-controller-skinny-model' }
      joshwlewis.com/slides/skinny-controller-skinny-model

= step :demo_time, x: 2000 do
  %h1.mb-2 Example App: Memefab
  %ul
    %li
      %a.h2{ href: 'https://memefab.herokuapp.com' } memefab.herokuapp.com
    %li
      %a.h2{ href: 'https://github.com/joshwlewis/memefab' } github.com/joshwlewis/memefab

= step :history, x: 4000 do
  %blockquote.blockquote.mb-2
    %h1.mb-1 Skinny Controller, Fat Model
    %h3.text-muted
      :plain
        - Jamis Buck, 2006

  %a.h4{ href: 'http://weblog.jamisbuck.org/2006/10/18/skinny-controller-fat-model' }
    weblog.jamisbuck.org/2006/10/18/skinny-controller-fat-model

= step :cowboy, x: 6000 do
  %div.text-center
    %h1.display-1.mb-2 🐴🤠🐮
    %h2.display-4 Pew Pew Pew!
    %h2.display-4 I'm a Cowboy!

= step :fat_controller, x: 8000 do
  %h1 The Fat Controller
  = code "ruby" do
    :plain
      class MemesController
        def create
          @meme = Meme.new(meme_params)
          @meme.upload_id = SecureRandom.uuid

          begin
            memeified = memeify(@meme.image, @meme.top, @meme.bottom)
            Cloud.upload(memefied, @meme.upload_id)
          rescue
            @meme.errors.add(:base, "Meme creation failed")
          end

          if @meme.valid? && @meme.save
            Twitter.update(url_for(@meme))
            flash[:notice] = "Successfully fabricated a fabulous meme."
            redirect_to @meme
          else
            Cloud.destroy(@meme.upload_id)
            render :edit
          end
        end

        private

        def memeify; redacted; end
        def meme_params; redacted; end
      end

= step :skinny_model, x: 10000 do
  %h2 The Skinny Model
  = code "ruby" do
    :plain
      class Meme
        belongs_to :image
        validates_presence_of :image
        validates_length_of :top, :bottom, maximum: 50
      end

= step :fat_controller_skinny_model, x: 12000 do
  %h1.mb-2 Fat Controller, Skinny Model
  %ul.list-unstyled
    %li.h3 👍 Model is only concerned with it's data
    %li.h3 👎 Controller has mixed concerns
    %li.h3 👎 Business logic is not reusable
    %li.h3 👎 Business logic can not be unit tested
    %li.h3 👎 Controller is tightly coupled

= step :skinny_controller, x: 14000 do
  %h1 The Skinny Controller
  = code "ruby" do
    :plain
      class MemesController
        def create
          @meme = Meme.new(meme_params)

          if @meme.save
            flash[:notice] = "Successfully fabricated a fabulous meme."
            redirect_to @meme
          else
            render :edit
          end
        end

        def meme_params; redacted; end
      end

= step :fat_model, x: 16000 do
  %h1 Fat Model
  = code "ruby" do
    :plain
      class Meme < ActiveRecord::Base
        before_validation :memeify_and_upload, on: :create
        after_create :post_to_twitter

        def memeify_and_upload
          self.upload_id = SecureRandom.uuid
          begin
            captioned_image = memeify(image, top, bottom)
            upload = Cloud.upload(captioned_image)
          rescue
            errors.add(:base, "Meme creation failed")
            Cloud.destroy(self.upload_id)
          end
        end

        def post_to_twitter
          Twitter.update(url_for(self))
        end
      end

= step :skinny_controller_fat_model, x: 18000 do
  %h1.mb-2 Skinny Controller, Fat Model
  %ul.list-unstyled
    %li.h3 👍 Controller is only concerned with serving requests
    %li.h3 👍 Business logic can be reused
    %li.h3 👍 Business logic may be unit tested
    %li.h3 👎 Model has mixed concerns
    %li.h3 👎 Model is tightly coupled
    %li.h3 👎 Order of operations is unclear
    %li.h3 👎 Surprising API

= step :where_does_business_logic_go, x: 20000 do
  %h1.mb-2 Business logic goes where?
  %ul.list-unstyled
    %li.h2 🙈 Model
    %li.h2 🙉 View
    %li.h2 🙊 Controller
    %li.h2 🤔 Something Else

= step :mediator_pattern, x: 22000 do
  %h2 The Mediator Pattern
  %blockquote.blockquote
    %p
      With the mediator pattern, communication between objects is encapsulated
      with a mediator object. Objects no longer communicate directly with each
      other, but instead communicate through the mediator. This reduces the
      dependencies between communicating objects, thereby lowering the coupling.

= step :installation, x: 24000 do
  %h1 No Installation

  %pre.highlight
    %code.text-strikethrough
      $ gem install mediators

  %h1 Just plain ol' Ruby
  = code "bash" do
    :plain
      $ mkdir app/mediators
  = code "ruby" do
    :plain
      # app/mediators/application_mediator.rb
      class ApplicationMediator
        def self.run(*args)
          new(*args).call
        end
      end

= step :fat_mediator, x: 26000 do
  %h1 The Fat Mediator
  = code "ruby" do
    :plain
      class MemeFabricator < ApplicationMediator
        def initialize(attrs = {}, model: Meme, uploader: Cloud, twitter: Twitter)
          @attrs, @model, @uploader, @twitter = attrs, model, uploader, twitter
        end

        def call
          memeify_image
          upload_image
          save_record
          post_to_twitter
          meme
        end

        def meme
          @meme ||= model.new(attributes.merge(upload_id: upload_id))
        end

        private

        attr_reader :attributes, :model, :uploader, :twitter

        def upload_id
          @upload_id ||= SecureRandom.uuid
        end

        def memeify_image
          @memefied ||= memeify(image, top, bottom)
        rescue
          meme.errors.add(:base, "Error captioning meme")
          raise
        end

        def upload_image
          uploader.upload(@memefied, upload_id)
        rescue
          meme.errors.add(:base, "Error uploading meme to cloud")
          raise
        end

        def save_record
          meme.save!
        rescue
          uploader.destroy(upload_id)
          raise
        end

        def post_to_twitter
          twitter.update(url_for(meme))
        end
      end


= step :skinny_controller_fat_mediator, x: 28000 do
  %h1 Skinny Controller, Fat Mediator
  = code "ruby" do
    :plain
      class MemesController
        def create
          creator = MemeFabricator.new(meme_params)
          @meme = creator.meme
          creator.call
          flash[:notice] = "Successfully fabricated a fabulous meme."
          redirect_to @meme
        rescue
          render :edit
        end

        def meme_params; redacted; end
      end

= step :skinny_model_fat_mediator, x: 30000 do
  %h1 Skinny Model, Fat Mediator
  = code "ruby" do
    :plain
      class Meme
        belongs_to :image
        validates_presence_of :image
        validates_length_of :top, :bottom, maximum: 50
      end

= step :trusty_methods, x: 32000 do
  %h1 A trusty API for business logic
  = code "ruby" do
    :plain
      # With fat model, you get unexpected side-effects
      Image.create({ upload_id: 123, meme_attributes: { top: "surprise!" })
      Image.last.build_meme(bottom: "you just posted to twitter").save
      Meme.find_or_create_by(top: "scary 😧")

      # With fat mediator, you choose when to execute side effects
      Meme.create(top: "trusty method call", bottom: "didnt tweet 🙌")
      MemeFabricator.run(top: "my mediators", bottom: "bring the tweeps to the yard")

= step :high_level_documentation, x: 34000 do
  %h1 High-level functionality documentation
  = code "bash" do
    :plain
      # With fat model, you understand only data.
      $ ls /app/models
      image.rb
      meme.rb

      # with fat mediator, you understand actions, too.
      $ ls /app/mediators
      image_uploader.rb
      meme_fabricator.rb


= step :low_level_documentation, x: 36000 do
  %h1 Low-level functionality documentation
  = code "ruby" do
    :plain
      # Actions to take and the order aren't immediately obvious
      class Meme < ApplicationRecord
        before_validation :memeify_and_upload, on: :create
        after_create :post_to_twitter
      end

  = code "ruby" do
    :plain
      # Actions to take and the order are immediately obvious
      class MemeFabricator < ApplicationMediator
        def call
          memeify_image
          upload_image
          save_record
          post_to_twitter
          meme
        end
      end

= step :simplifies_unit_testing, x: 40000 do
  %h1 Simpler Unit Testing
  = code "ruby" do
    # With fat model, constants must be stubbed to mock
    test "uploads to cloud" do
      mock = Minitest::Mock.new
      mock.expect(:call, nil, [String])
      Twitter.stub(:update, mock) do
        Meme.create(top: "stubbed constant", bottom: "with a mock")
      end
      assert mock.verify
    end

    # With fat mediator, pass in mocks as dependencies
    test "uploads to cloud" do
      mock = Minitest::Mock.new
      mock.expect(:update, nil, [String])
      MemeFabricator.run(top: "just a", bottom: "mock", twitter: mock)
      assert mock.verify
    end

= step :skinny_controller_skinny_model_fat_mediator, x: 38000 do
  %h1.mb-2 Skinny Controller, Skinny Model, Fat Mediator
  %ul.list-unstyled
    %li.h3 👍 Controller is only concerned with serving requests
    %li.h3 👍 Model is only concerned with it\'s data
    %li.h3 👍 Business logic may be reused
    %li.h3 👍 Business logic may be unit tested
    %li.h3 👍 Order of operations is clear
    %li.h3 👍 API is unsurprising
    %li.h3 👎 Net lines of code increased

